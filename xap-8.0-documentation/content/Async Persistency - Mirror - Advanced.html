<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
     <head>
         <title>XAP 8.0 Documentation : Async Persistency - Mirror - Advanced</title>
<link rel="stylesheet" href="styles/site.css" type="text/css" />
         <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
		 <style>
.back-to {
	color: #666666;
	font-weight: bold;
}	 
a.back-to:link, a.back-to:visited, a.back-to:hover, a.back-to:active  {
	color: #666666;
}	 
		 </style>
     </head>

     <body>
<table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
<tr>
<td valign="top" class="pagebody">
<div class="pageheader">
<span class="back-to">XAP 8.0 Documentation > <a href="index.html">Back to Table of Contents</a></span><br>
<h1>Async Persistency - Mirror - Advanced</h1>
</div>
<br>

<script type='text/javascript'>//<![CDATA[
function debug() { }
// ]]></script><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/browser.js'>//<![CDATA[
// ]]></script><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/behaviour.js'>//<![CDATA[
// ]]></script><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/memory.js'>//<![CDATA[
// ]]></script><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/cloak.js'>//<![CDATA[
// ]]></script><script type='text/javascript'>//<![CDATA[
Cloak.closeHTML = "<img src=\'/wiki/download/resources/net.customware.confluence.plugin.composition:toggle-cloak/img/navigate_down_10.gif\'/>";
Cloak.openHTML = "<img src=\'/wiki/download/resources/net.customware.confluence.plugin.composition:toggle-cloak/img/navigate_right_10.gif\'/>";
Cloak.toggleZone = true;
Cloak.memoryDuration = 0;
Cloak.memoryPrefix = "contentId:53903383";
Cloak.memoryPath = "/wiki/";
// ]]></script><style type='text/css'>
.cloakToggle { /* Definition for state toggling image */
cursor:hand;
cursor:pointer;
}
</style><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/transitions.js'>//<![CDATA[
// ]]></script><script type='text/javascript' src='/wiki/download/resources/net.customware.confluence.plugin.composition:composition-setup/js/deck.js'>//<![CDATA[
// ]]></script><link rel='stylesheet' type='text/css'  href='/wiki/styles/main-action.css?pluginCompleteKey=net.customware.confluence.plugin.composition:composition-setup&stylesheetName=deck&spaceKey=XAP8'/><script type='text/javascript'>//<![CDATA[
Deck.memoryDuration = 0;
Deck.memoryPrefix = "contentId:53903383";
Deck.memoryPath = "/wiki/";
// ]]></script>


<div style="border-style:solid; border-color:#3C78B5; border-width:thin; padding-left:20px; padding-bottom:20px; padding-top:20px; padding-right:20px; background-color:#D8E4F1"> 

<p><b>Section Summary:</b>  Reliable Asynchronous Persistency (Mirror) - advanced topics. </p>
</div>

<h1><a name="AsyncPersistency-Mirror-Advanced-CustomMirrorServiceName"></a>Custom Mirror Service Name</h1>

<p>A Mirror Service can be configured per Space cluster. You can't have multiple Mirror services configured for the same space cluster. <br/>
If you need "multiple mirrors" for the same space cluster you can implement a Mirror Service that will route the data and operations to other multiple "agents" that will persist the data - effectively make the default Mirror act as a dispatcher.</p>

<p>If you have multiple different space clusters, each with its own Mirror service running, you should have a different name used for each Mirror Service.</p>

<p>The Mirror Service name used as part of the space config is specified via the <tt>"cluster-config.mirror-service.url"</tt> property. Its default is <tt>"jini://*/mirror-service_container/mirror-service"</tt> which match the "mirror-service" that is used as part of the <tt>url</tt> property used to start the mirror service.</p>

<p>As an example, let's say we would like to call my mirror service <tt>mymirror-service</tt> (instead of the default <tt>mirror-service</tt>). Here is how the mirror service should be started:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-xml">&lt;os-core:space id=<span class="code-quote">"space"</span> url=<span class="code-quote">"/./mymirror-service"</span> schema=<span class="code-quote">"mirror"</span> 
    external-data-source=<span class="code-quote">"hibernateDataSource"</span> /&gt;</pre>
</div></div>

<p>Here is how the space should be started:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-xml">&lt;os-core:space id=<span class="code-quote">"space"</span> url=<span class="code-quote">"/./mySpace"</span> schema=<span class="code-quote">"persistent"</span> 
    mirror=<span class="code-quote">"true"</span> external-data-source=<span class="code-quote">"hibernateDataSource"</span>&gt;
    <span class="code-tag">&lt;os-core:properties&gt;</span>
        <span class="code-tag">&lt;props&gt;</span>
            <span class="code-tag">&lt;prop key=<span class="code-quote">"cluster-config.mirror-service.url"</span>&gt;</span>
                jini://*/mymirror-service_container/mymirror-service
            <span class="code-tag">&lt;/prop&gt;</span>
        <span class="code-tag">&lt;/props&gt;</span>
    <span class="code-tag">&lt;/os-core:properties&gt;</span>
<span class="code-tag">&lt;/os-core:space&gt;</span></pre>
</div></div>

<h1><a name="AsyncPersistency-Mirror-Advanced-ImplementingaCustomMirrorDataSource"></a>Implementing a Custom Mirror Data Source</h1>

<p>The External Data Source used by the mirror needs to implement <tt>com.gigaspaces.datasource.BulkDataPersister</tt>. GigaSpaces comes with a <a href="Hibernate External Data Source.html" title="Hibernate External Data Source">Hibernate External Data Source</a> implementation that implements this interface. You can implement your own Mirror very easily to accommodate your exact needs. See example below:</p>

<p><span id='tgl_content_custom' class='cloakToggle'></span><font color="#88aed2"><b>Show code...</b></font></p>


<div class="panel" style="background-color: white;border-style: none;border-width: 1px;"><div class="panelContent" style="background-color: white;">
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java"><span class="code-keyword">package</span> eg;

...

<span class="code-keyword">public</span> class MyDataSource <span class="code-keyword">implements</span> BulkDataPersister {

    <span class="code-keyword">private</span> <span class="code-object">String</span> myParameter;

    <span class="code-keyword">public</span> void init(Properties properties) <span class="code-keyword">throws</span> DataSourceException {
        <span class="code-comment">// usually, nothing to <span class="code-keyword">do</span> here since parameters can be injected using Spring
</span>    }

    <span class="code-keyword">public</span> void setMyParameter(<span class="code-object">String</span> myParameter) {
        <span class="code-keyword">this</span>.myParameter = myParameter;
    }

    <span class="code-keyword">public</span> void shutdown() <span class="code-keyword">throws</span> DataSourceException {
         <span class="code-comment">// put shutdown logic here or implement Spring DisposableBean and use destroy method
</span>    }

    <span class="code-keyword">public</span> void executeBulk(List&lt;BulkItem&gt; bulkItems) <span class="code-keyword">throws</span> DataSourceException {
        <span class="code-keyword">for</span> (BulkItem bulkItem : bulkItems) {
            <span class="code-object">Object</span> item = bulkItem.getItem();
            <span class="code-keyword">switch</span> (bulkItem.getOperation()) {
                <span class="code-keyword">case</span> BulkItem.REMOVE:
                    <span class="code-comment">// use item information to remove it from data store
</span>                    <span class="code-keyword">break</span>;
                <span class="code-keyword">case</span> BulkItem.WRITE:
                    <span class="code-comment">// use item information to write it into data store
</span>                    <span class="code-keyword">break</span>;
                <span class="code-keyword">case</span> BulkItem.UPDATE:
                    <span class="code-comment">// use item to update it in data store
</span>                    <span class="code-keyword">break</span>;
            }
        }
    }
}</pre>
</div></div>
</div></div>



<p>And here is how this can be configured within the mirror configuration:</p>

<p><span id='tgl_content_config' class='cloakToggle'></span><font color="#88aed2"><b>Show configuration...</b></font></p>


<div class="panel" style="background-color: white;border-style: none;border-width: 1px;"><div class="panelContent" style="background-color: white;">
<div id="deck:os_simple_space" class="deck" tablocation="top" style="display: none" loopcards="false"><div class="cards tabbed">
<div class="card" label="Namespace" labelrendered="Namespace">
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-xml"><span class="code-tag">&lt;bean id=<span class="code-quote">"myDataSource"</span> class=<span class="code-quote">"eg.MyDataSource"</span>&gt;</span>
    <span class="code-tag">&lt;property name=<span class="code-quote">"myParameter"</span> value=<span class="code-quote">"myValue"</span>/&gt;</span>
<span class="code-tag">&lt;/bean&gt;</span>

&lt;os-core:space id=<span class="code-quote">"space"</span> url=<span class="code-quote">"/./mirror-service"</span> schema=<span class="code-quote">"mirror"</span> 
    external-data-source=<span class="code-quote">"myDataSource"</span> /&gt;</pre>
</div></div>
</div>
<div class="card" label="Plain XML" labelrendered="Plain XML">
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-xml"><span class="code-tag">&lt;bean id=<span class="code-quote">"myDataSource"</span> class=<span class="code-quote">"eg.MyDataSource"</span>&gt;</span>
    <span class="code-tag">&lt;property name=<span class="code-quote">"myParameter"</span> value=<span class="code-quote">"myValue"</span>/&gt;</span>
<span class="code-tag">&lt;/bean&gt;</span>

<span class="code-tag">&lt;bean id=<span class="code-quote">"space"</span> class=<span class="code-quote">"org.openspaces.core.space.UrlSpaceFactoryBean"</span>&gt;</span>
    <span class="code-tag">&lt;property name=<span class="code-quote">"url"</span> value=<span class="code-quote">"/./mirror-service"</span> /&gt;</span>
    <span class="code-tag">&lt;property name=<span class="code-quote">"scheam"</span> value=<span class="code-quote">"mirror"</span> /&gt;</span>
    <span class="code-tag">&lt;property name=<span class="code-quote">"externalDataSource"</span> ref=<span class="code-quote">"myDataSource"</span> /&gt;</span>
<span class="code-tag">&lt;/bean&gt;</span></pre>
</div></div>
</div>
</div></div>
</div></div>



<ol>
	<li>In order to use the data source as the read mechanism for the cluster Space that connects to the mirror, additional interfaces need to implemented called <tt>DataProvider</tt> or possibly <tt>SQLDataProvider</tt>.</li>
</ol>


<h1><a name="AsyncPersistency-Mirror-Advanced-MultipleMirrors"></a>Multiple Mirrors</h1>
<p>In some cases you may need to asynchronously persist data both into a relational database and a file, or persist the data into a relational database and transfer some of the data into some other system. </p>

<p>In such a case you may need to have multiple mirrors. In order to implement this, you should have one base mirror (for example the Hibernate External Data Source) and extend it to include the extra functionality you may need.</p>

<p>See the <a href="http://www.gigaspaces.com/wiki/display/SBP/Mirror+Monitor" title="Mirror Monitor">Mirror Monitor</a> for a simple example how such approach should be implemented.</p>

<h1><a name="AsyncPersistency-Mirror-Advanced-HandlingMirrorExceptions"></a>Handling Mirror Exceptions </h1>
<p>Since the external data source configured for the mirror service communicates with the database, it may run into database related errors, such as constraint violations, wrong class mappings (if the Hibernate-based external data source implementation is used), and other database related errors. </p>

<p>By default these errors are propagated to the replicating space (primary space instance), and will appear in its logs. In such a case, the primary space will try to replicate the batch the caused the error to the mirror service again, until it succeeds (meaning that no exception has been thrown).  </p>

<p>To override and extend this behavior, you can implement an exception handler that will be called when an exception is thrown from the Mirror back to the primary space. This exception handler can log the exception at the mirror side, throw it back to the space, ignore it or execute any user specific code. Here is an example of how this is done using the <tt>org.openspaces.persistency.patterns.BulkDataPersisterExceptionHandler</tt> provided with openspaces:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-xml">&lt;bean id=<span class="code-quote">"originalHibernateDataSource"</span> 
    class=<span class="code-quote">"org.openspaces.persistency.hibernate.DefaultHibernateExternalDataSource"</span>&gt;
    <span class="code-tag">&lt;property name=<span class="code-quote">"sessionFactory"</span> ref=<span class="code-quote">"sessionFactory"</span>/&gt;</span> <span class="code-tag">&lt;/bean&gt;</span>
 
<span class="code-tag">&lt;bean id=<span class="code-quote">"exceptionHandler"</span> class=<span class="code-quote">"eg.MyExceptionHandler"</span>/&gt;</span>
 
&lt;bean id=<span class="code-quote">"exceptionHandlingEDS"</span> 
    class=<span class="code-quote">"org.openspaces.persistency.patterns.BulkDataPersisterExceptionHandler"</span>&gt;
    <span class="code-tag">&lt;constructor-arg ref=<span class="code-quote">"originalHibernateDataSource"</span>/&gt;</span>
    <span class="code-tag">&lt;constructor-arg ref=<span class="code-quote">"exceptionHandler"</span>/&gt;</span>
<span class="code-tag">&lt;/bean&gt;</span>
 
&lt;os-core:space id=<span class="code-quote">"space"</span> url=<span class="code-quote">"/./mirror-service"</span> schema=<span class="code-quote">"mirror"</span> 
    external-data-source=<span class="code-quote">"exceptionHandlingEDS"</span>/&gt;</pre>
</div></div>

<p>With the above, we use the <tt>BulkDataPersisterExceptionHandler</tt>, and wrap the <tt>DefaultHibernateExternalDataSource</tt> with it (and pass that to the space). On the <tt>BulkDataPersisterExceptionHandler</tt> we set our own implementation of the <tt>ExceptionHandler</tt>, to be called when there is an exception. With the <tt>ExceptionHandler</tt> you can decide what to do with the Exception: "swallow it", execute some logic, or rethrow it.</p>

<div class='panelMacro'><table class='warningMacro'><colgroup><col width='24'><col></colgroup><tr><td valign='top'><img src="images/icons/emoticons/forbidden.gif" width="16" height="16" align="absmiddle" alt="" border="0"></td><td>It's critical to <em>test your persistence in the mirror</em>.<br clear="all" /> <br clear="all" />
A configured mirror will repeatedly try to store things in the DB. In the case on unrecoverable failure (imagine an invalid mapping or a constraint issue), this can cause the redo log to grow, eventually resulting in overflow of the redo to disk, and then, when the predefined disk capacity is exhausted, leading to a rejection of any non-read space operation (similar to how the memory manager works). The exception that clients will see in this case is RedologCapacityExceededException (which inherits from ResourceCapacityExceededException).<br clear="all" /> <br clear="all" />
The application can handle this by using the ExceptionHandler at the mirror EDS level. It can count the number of consecutive failures returned from the DB and when a certain threshold is reached, log it somewhere and move on, for example.<br clear="all" /> <br clear="all" />
That said, the easiest thing to do is <em>test your persistence in the mirror</em>.</td></tr></table></div>

<h1><a name="AsyncPersistency-Mirror-Advanced-MirrorbehaviorwithDistributedTransactions"></a>Mirror behavior with Distributed Transactions</h1>

<p>When using the Jini Distributed Transaction Manager and persisting data through the mirror service, each partition send its transaction data to the Mirror on commit. The mirror service receives the replication bulks from each partition that participated in the transaction. In order to keep data consistency when persisting the data, these bulks should to be consolidated at the mirror service.<br/>
This can be achieved by :</p>
<ol>
	<li>Setting the following property in the mirror configuration:
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">&lt;os-core:space id=<span class="code-quote">"mirror"</span> url=<span class="code-quote">"/./mirror-service"</span> schema=<span class="code-quote">"mirror"</span> external-data-source=<span class="code-quote">"eds"</span>&gt;
    &lt;os-core:properties&gt;
	&lt;props&gt;
	     &lt;prop key=<span class="code-quote">"space-config.mirror-service.operation-grouping"</span>&gt;group-by-space-transaction&lt;/prop&gt;
	&lt;/props&gt;
    &lt;/os-core:properties&gt;    
&lt;/os-core:space&gt;</pre>
</div></div></li>
</ol>


<p>By default this property is set to <tt>group-by-replication-bulk</tt> and executeBulk() groups several transactions and executes them together. The group size is defined by the mirror replication bulk-size.<br/>
Setting this property will cause the mirror to execute each transaction separately and fill the BulkDataPersisterContext transaction data.</p>

<div class='panelMacro'><table class='noteMacro'><colgroup><col width='24'><col></colgroup><tr><td valign='top'><img src="images/icons/emoticons/warning.gif" width="16" height="16" align="absmiddle" alt="" border="0"></td><td>If this property is not set, the BulkDataPersisterContext won't contain any transactional data</td></tr></table></div>

<ol>
	<li>Implementing the <tt>BulkDataPersister.executeBulk()</tt> using the <tt>BulkDataPersisterContext</tt>.</li>
</ol>


<p>Example:</p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java"><span class="code-keyword">public</span> void executeBulk(List&lt;BulkItem&gt; bulk) <span class="code-keyword">throws</span> DataSourceException {
            BulkDataPersisterContext context = BulkDataPersisterContext.getCurrentContext();

            <span class="code-keyword">if</span> (context.isTransactional()) {
                TransactionParticipantData txData = context.getTransactionData();
                          
                <span class="code-object">long</span> id = txData.getTransactionId();
                <span class="code-object">int</span> participantId = txData.getParticipantId();
                <span class="code-object">int</span> participantsCount = txData.getParticipantsCount();

                <span class="code-comment">// add to pending transactions      
</span>                ....

                
                <span class="code-comment">// <span class="code-keyword">if</span> all transactions parts arrived - execute bulk
</span>                ....

            }
            <span class="code-keyword">else</span>
            {
               <span class="code-comment">//regular execution
</span>               ....
            }

        }</pre>
</div></div>


<p>The TransactionParticipantData.java:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java"><span class="code-keyword">package</span> net.jini.core.transaction.server;

/**
 * Interface <span class="code-keyword">for</span> Jini transaction participant data.
 * Contains information about transaction at the time of commit .
 * @since 7.1
 */
<span class="code-keyword">public</span> <span class="code-keyword">interface</span> TransactionParticipantData
{

    /**
     * The id of the space that committed the transaction. &lt;br&gt;
     * @<span class="code-keyword">return</span> the participantId
     */
    <span class="code-keyword">public</span> <span class="code-object">int</span> getParticipantId();

    /**
     * <span class="code-object">Number</span> of participants in transaction
     * @<span class="code-keyword">return</span> the participantsCount
     */
    <span class="code-keyword">public</span> <span class="code-object">int</span> getParticipantsCount();

    /**
     * The id of the distributed transaction
     * @<span class="code-keyword">return</span> the transactionId
     */
    <span class="code-keyword">public</span> <span class="code-object">long</span> getTransactionId();
      

}</pre>
</div></div>

<p>Notes: <br/>
1. <tt>executeBulk()</tt> is called concurrently, so implementation should take it into consideration.<br/>
2. Both transactional and non-transactional operations are persisted through the <tt>executeBulk</tt>, so both options should be considered.<br/>
3. Transactional operations - each call to <tt>executeBulk()</tt> contains items that belong to a single transaction - meaning the whole transaction is passed in a single <tt>executeBulk()</tt> and no other items from other transactions or non-transactional items are passed. <br/>
4. Non-transactional operations are grouped according to the replication policy (bulk-size and interval-millis) and sent to the Mirror Service. <br/>
5. Transactional and non-transactional items are not mixed. </p>

<h1><a name="AsyncPersistency-Mirror-Advanced-UsageScenarios"></a>Usage Scenarios</h1>

<div class="error"><span class="error">Error formatting macro: toc-zone: java.lang.NullPointerException</span> 

<h2><a name="AsyncPersistency-Mirror-Advanced-WritingAsynchronouslytotheMirrorDataSource"></a>Writing Asynchronously to the Mirror Data Source</h2>

<p>The following is a schematic flow of a synchronous replicated cluster with three members, which are communicating with a Mirror Service:</p>

<div class="indent20 inline" style="margin-left: 20px;"><style type="text/css">div.inline p:first-child { display: inline; }</style><p><img src="download/attachments/48235229/IMG101.gif" align="absmiddle" border="0"/></p></div>

<h2><a name="AsyncPersistency-Mirror-Advanced-ReadingfromtheDataSource"></a>Reading from the Data Source</h2>

<p>The Mirror Service space is used to asynchronously <b>persist</b> data into the data source. As noted elsewhere, the Mirror is <b>not</b> a regular space, and should <b>not</b> be interacted with directly. Thus, data can't be read from the data source using the Mirror Service space. Nonetheless, the data might be read by other spaces which are configured with an external data source.</p>

<p><img class="emoticon" src="images/icons/emoticons/warning.gif" height="16" width="16" align="absmiddle" alt="" border="0"/> For consistency reasons, it is important that the spaces reading from the external data source are configured to have <b><tt>read-only</tt></b> external-data-source usage mode, unless your application logic requires differently.</p>

<p>The data-grid pu.xml needs to be configured to use an <b>external data source</b> which, when dealing with a Mirror, is <b>central</b> to the cluster.</p>

<p>Here is a schematic flow of how a Mirror Service asynchronously receives data, to persist into an external data source, while the cluster is reading data directly from the external data source.</p>

<div class="indent20 inline" style="margin-left: 20px;"><style type="text/css">div.inline p:first-child { display: inline; }</style><p><img src="download/attachments/48235229/IMG103.gif" align="absmiddle" border="0"/></p></div>

<h2><a name="AsyncPersistency-Mirror-Advanced-PartitioningOveraCentralMirrorDataSource"></a>Partitioning Over a Central Mirror Data Source</h2>

<p>When partitioning data, each partition asynchronously replicates data into the Mirror Service. Each partition can read back data that belongs to it (according to the load-balancing policy defined).</p>

<p>Here is a schematic flow of how two partitions (each a primary-backup pair) asynchronously interact with an external data source:</p>

<div class="indent20 inline" style="margin-left: 20px;"><style type="text/css">div.inline p:first-child { display: inline; }</style><p><img src="download/attachments/48235229/IMG104.gif" align="absmiddle" border="0"/></p></div>
</div>

<p><a name="AsyncPersistency-Mirror-Advanced-disttxnmirror"></a></p>

<h1><a name="AsyncPersistency-Mirror-Advanced-ConsiderationsandKnownIssues"></a>Considerations and Known Issues</h1>
<p><img class="emoticon" src="images/icons/emoticons/warning.gif" height="16" width="16" align="absmiddle" alt="" border="0"/> <a href="External Data Source Advanced Topics.html#ExternalDataSourceAdvancedTopics-limits">External data source considerations</a> also apply to the Mirror Service.</p>
<ul>
	<li>The Mirror Service cannot be used with a single space or the <tt>partitioned</tt> cluster schema. It is supported with the <tt>sync-replicated</tt>, <tt>async-replicated</tt>, and <tt>partitioned-sync2backup</tt> cluster schemas.</li>
	<li>The Mirror Service is a single space which joins a replication group. The Mirror Service is not a clustered space or part of the replication group declaration.</li>
	<li>When the Mirror Service is loaded, it does not perform memory recovery. See the <a href="#AsyncPersistency-Mirror-Advanced-reliability">reliability section</a> for more details.</li>
	<li><a href="Transient Entries.html" title="Transient Entries">Transient Entries</a> are not persisted into the data source - just like in any other persistent mode.</li>
	<li>Unlike other external data source interfaces, the <tt>com.gigaspaces.datasource.BulkDataPersister</tt> interface doesn't differentiate between Space API and Map API operations. The call to <tt>com.gigaspaces.datasource.BulkItem.getItem()</tt> returns either the user entity when using the Space API, or the <tt>java.util.Map.Entry</tt> when using the Map API.</li>
	<li>When using an Jini Entry as your space class, it must have getters and setters for all public fields.</li>
	<li>You should have one Mirror Service running per Data-Grid cluster.</li>
	<li>The Mirror Service cannot be clustered. Deploying it as a Processing unit ensures its high-availability.</li>
	<li>The Mirror does not load data back into the space. the <tt>External Data Source</tt> implementation of the space should be used to initialize the space when started.</li>
</ul>


<h1><a name="AsyncPersistency-Mirror-Advanced-Troubleshooting"></a>Troubleshooting</h1>

<h2><a name="AsyncPersistency-Mirror-Advanced-LogMessages"></a>Log Messages</h2>

<p>The external data source logging level can be modified as part of the <tt>&lt;GigaSpaces Root&gt;\config\gs_logging.properties</tt> file. By default, it is set to <tt>java.util.logging.Level.INFO</tt>:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">com.gigaspaces.persistent.level = INFO</pre>
</div></div>

<p>Logging is divided according to <tt>java.util.logging.Level</tt> as follows:</p>
<div class="indent20 inline" style="margin-left: 20px;"><style type="text/css">div.inline p:first-child { display: inline; }</style><table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Level </th>
<th class='confluenceTh'> Description </th>
</tr>
<tr>
<td class='confluenceTd'> <tt>INFO</tt> </td>
<td class='confluenceTd'> The default level for informative messages. </td>
</tr>
<tr>
<td class='confluenceTd'> <tt>CONFIG</tt> </td>
<td class='confluenceTd'> Mirror Service-relevant configuration messages. </td>
</tr>
<tr>
<td class='confluenceTd'> <tt>FINER</tt> </td>
<td class='confluenceTd'> Fairly detailed messages of:
<ul>
	<li><b>Entering and exiting</b> interface methods (displaying the parameter's <tt>toString()</tt> method)</li>
	<li><b>Throwing of exceptions</b> between the space and the underlying implementation.</li>
</ul>
</td>
</tr>
</tbody></table></div>

<h1><a name="AsyncPersistency-Mirror-Advanced-FailoverHandling"></a>Failover Handling </h1>
<p>This section describes how the GigaSpaces Mirror Service handles different failure scenarios. The following table lists the services involved, and how the failure is handled in the cluster.</p>

<p>Active services are <font color="green"><b>green</b></font>, while failed services are <font color="red"><b>red</b></font>.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Active/Failed Services </th>
<th class='confluenceTh'> Cluster Behavior </th>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>The primary and backup spaces, each include a copy of the mirror replication queue, (which is created in the backup, as part of the synchronized replication between the primary and the backup).</li>
	<li>The mirror doesn't acknowledge the replication until the data is successfully committed to the database.</li>
	<li>Every time the primary gets an acknowledgment from the mirror, it notifies the backup of the last exact point in the replication queue where replication to the mirror was successful.</li>
	<li>This way, the primary and backup space include the same copy of the data and are also in sync with which data was replicated to the mirror and written to the database.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="red">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>The backup space holds all the information in-memory, since the replication channel between them is synchronous.</li>
	<li>The backup space is constantly notified of the last exact point in the replication queue where replication to the mirror was successful. This means that it knows specifically when the failure occurred. Therefore, it replicates the data received from that point onwards, to the mirror.</li>
	<li>One possible scenario is that the same Entry is sent to the mirror, both by the primary and the backup space. However, the mirror handles this situation, so no data is lost or duplicated.</li>
	<li>If the primary space is restarted (typically by the Service Grid infrastructure), it recovers all of the data from the backup space. Once the primary has retrieved all data from the backup, it continues replicating as usual. No data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="red">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>The primary keeps functioning as before: replicating data to the mirror and persisting data asynchronously, so no data is lost.</li>
	<li>The primary space is constantly notified of the last exact point in the replication queue where replication to the mirror was successful. This means that it knows specifically when the failure occurred. Therefore, it replicates the data received from that point onwards to the mirror.</li>
	<li>One possible scenario is that the same Entry is sent to the mirror both by the primary and the backup space. However, the mirror handles this situation, so no data is lost or duplicated.</li>
	<li>If the backup space is restarted (typically by the Service Grid infrastructure), it recovers all of the data from the primary space. Once the backup has retrieved all data from the primary, it continues replicating as usual. No data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="green">Back Up</font></li>
	<li><font color="red">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>The primary and backup spaces accumulate the Entries and replicate them to their mirror replication queue (which is highly available since they both share it).</li>
	<li>When the mirror is restarted, replication is resumed from the point it was stopped, prior to the failure. No data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="red">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>The primary space is constantly synchronized with the mirror, which stops sending acknowledgments or starts sending errors to it.</li>
	<li>The primary and backup spaces accumulate the Entries and replicate them to their mirror replication queue (which is highly available since they both share it).</li>
	<li>When the database is restarted, the mirror reconnects to it and persistency is resumed from the point it was stopped, prior to the failure. No data is lost.</li>
</ul>
</td>
</tr>
</tbody></table>

<h1><a name="AsyncPersistency-Mirror-Advanced-UnlikelyFailureScenarios"></a>Unlikely Failure Scenarios</h1>

<p>The following failure scenarios are highly unlikely. However, it might be useful to understand how such scenarios are handled by GigaSpaces. This is detailed in the table below.</p>

<p>Active services are <font color="green"><b>green</b></font>, while failed services are <font color="red"><b>red</b></font>.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Active/Failed Services </th>
<th class='confluenceTh'> Cluster Behavior </th>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="red">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="red">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>Data which has already been saved in the database is safe.</li>
	<li>Data held in the mirror replication queue still exists in the backup, so no data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="red">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="red">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>Data which has already been saved in the database is safe.</li>
	<li>Data held in the mirror replication queue still exists in the backup, so no data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="red">Backup</font></li>
	<li><font color="red">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'> Same as above &#8211; no data is lost. </td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="red">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="red">Database</font></li>
</ul>
</td>
<td class='confluenceTd'> Same as above &#8211; no data is lost. </td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="green">Primary</font></li>
	<li><font color="green">Backup</font></li>
	<li><font color="red">Mirror</font></li>
	<li><font color="red">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>Data which has already been saved in the database is safe.</li>
	<li>Data queued in the mirror replication queue still exists in the primary and the backup, so no data is lost.</li>
</ul>
</td>
</tr>
<tr>
<td class='confluenceTd'><ul>
	<li><font color="red">Primary</font></li>
	<li><font color="red">Backup</font></li>
	<li><font color="green">Mirror</font></li>
	<li><font color="green">Database</font></li>
</ul>
</td>
<td class='confluenceTd'><ul>
	<li>All data that was successfully replicated to the mirror (and hence persisted to the database) is safe.</li>
	<li>Data queued in the mirror replication queue in the primary and backup spaces is lost.</li>
	<li>If you encounter this scenario, a configuration with two backups per partition should be considered.</li>
</ul>
</td>
</tr>
</tbody></table>

                     </td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td height="12" background="http://www.gigaspaces.com/wiki/images/border/border_bottom.gif"><img src="images/border/spacer.gif" width="1" height="1" border="0"/></td>
</tr>
<tr>
<td align="center"><font color="grey"><a href="http://www.gigaspaces.com">GigaSpaces.com</a> -
		<a href="http://www.gigaspaces.com/wiki/x/xwBmAg" class="smalltext">Legal Notice</a> -
		<a href="http://www.gigaspaces.com/wiki/x/xgBmAg" class="smalltext">3rd Party Licenses</a> -
		<a href="http://www.gigaspaces.com/wiki/x/BQFmAg" class="smalltext">Site Map</a> -
		<a href="http://www.gigaspaces.com/wiki/display/API/API+Documentation+Portal" class="version-link">API Docs</a> -
		<a href="http://forum.openspaces.org/forum.jspa?forumID=175" class="version-link">Forum</a> -
		<a href="http://www.gigaspaces.com/LatestProductVersion" class="version-link">Downloads</a> -
		<a href="http://blog.gigaspaces.com/" class="version-link">Blog</a> -
		<a href="http://www.gigaspaces.com/os_papers.html" class="version-link">White Papers</a> -
		<a href="mailto:techw@gigaspaces.com">Contact Tech Writing</a> -
		<i><a href="http://www.atlassian.com/software/confluence">Gen. by Atlassian Confluence</a></i></font></td>
</tr>
</table>
     </body>
</html>
